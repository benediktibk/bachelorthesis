\chapter{Routing}

Even nowadays the routing is often done manually for analog circuits. This is mainly caused by a lack of good tools and consequently the missing trust of engineers in them. The engineers consider a lot of different constraints during the routing, for example symmetries, net lengths and capacitive couplings. All these things have a major impact on the performance of the circuit, as it is very important in the analog world to have a really accurate signal level because only high or low isn't enough.

The designer additonally adds guards and rings to the placement to protect certain devices from noise. This noise can come from for example the clock net or other routes, which carry a signal with high frequency. But high frequencies aren't the only disturbing effects, already during the placement the designer has to consider temperature gradients, caused by transistors with a high power consumption. To avoid problems with different temperatures in the substrate of for example the devices of a differential pair they can be placed symmetric or can even have a common centroid. Around these grouped modules then the designer can create for example a guard ring to protect the devices even more. An example for a manually routed layout can be seen in \nref{fig:miller_amplifier_routed_layout}.

So for an automatic routing algorithm a lot of different constraints must be considered. There are even more obstacles than just the devices and already created routes, for example the routes should pass over guard rings. To solve this problem in the following chapter are two different approaches presented: One simple sequentially line expansion router and one extend version of the previous one, which considers additional constraints. But first I'll  discuss the changes that were necessary for the implementation of the routing algorithms.

\begin{figure}
	\centering
	\includegraphics[scale=.4]{FIG/miller_amplifier_layout_routed.png}
  	\caption{manually routed layout of a miller amplifier}
	\label{fig:miller_amplifier_routed_layout}
\end{figure}

\section{Changes for Routing in the existing Applications}

\subsection{Plantage}

\subsubsection{Missing Data}
To actually route the placements some data was missing in Plantage. Although at some points the routing was already prepared, example given the net names were available, important information was not given. These include:
\begin{itemize}
\item Actual dimensions of the modules
\item Parameter of the technology
\item Vias and routes
\item Guard rings
\end{itemize}

In awareness of the necessary routing for every module a bigger area was defined for the placement. The additional space between the modules could then be used to route the placement. But the information about the actual dimension of the modules was lost through this step. Therefore I withdrawed these changes and added the possibility to define a minimum distance between all modules.

The technology rules are passed through by the ICFBInterface to Plantage. At least for the technology definitions of Austria Microsystems it is not necessary to convert these rules, as the same format is chosen. For other manufacturers a conversion might be necessary.

The vias and routes were not considered at all previously. The main information which is needed to route are the dimension of the vias on the different layers and the width for the routes. Actually there is no real width for a route, but a minimal width, which a route must have. Usually this width is used for the routes. Also the dimensions for the via must be caculated, which can be done as described previously. Also the generated routes and placed vias needed to be added to the output of Plantage, so that they can be shown in the GUI.

Previously every pin consisted only of one rectangle, which is obviously not enough. This basic information was used to minimize the estimated net length for the placements. But for real routing we need more complex possibilities to define pins, as, for example, the gate can be connected from both sides. Also it is not recommend to contact over the diffusion area. This will result in even more complex contact areas, as they could be split up in different parts. The definition of these areas is done by the user in the GUI and handed over to Plantage. The used format defines for every pin, which a module has, at least one contact area, but eventually a lot more. During the routing then the acutal contact area is selected based on a certain heuristic.

\subsection{ICFBInterface}
The GUI-part of this application also needed some adaptions. This work was mainly done by Martin Ke√üler and contained the following parts:

\begin{itemize}
\item possibility to define contact areas
\item displaying routes and vias
\item possibility to change algorithm settings
\end{itemize}	

\section{Overview of Routing Algorithms}
A really nice overview of the existing routing algorithms and the different approaches can be found in \cite[page 149 till 201]{springer:eda_analog_routing}. The more sophisticated routing algorithms described there are based on two basic algorithms:
\begin{itemize}
\item Maze Router
\item Line Router
\end{itemize}
These algorithms are so-called general purpose router, they can be used for global and detailed routing. To find out which type of algorithm may be appropiate in my case I will take a short look on the most important algorithms.

\subsection{Basic Routing Algorithms}
\subsubsection{Maze Router}
Another often used name for algorithm is Lee's algorithm. But whatever the name is, it is based on a grid, where the obstacles and pins can be filled in. Basically, this is the whole information, which is necessary for the router. Afterwards a wave of numbers is started from one pin, and if this wave reaches the target a possible routing is found \nref{fig:maze_router}. The router guarantees the shortest possible route and will find a route in all cases, if it is possible \cite[p. 693]{kaufmann:electronic_design_automation}. So basically this is a very simple approach, but it has several drawbacks. First of all it is quite slow and very memory consuming \cite[p. 693]{kaufmann:electronic_design_automation}, as a quite big matrix might be necessary. This memory consumption also relies heavily on the grid size, which raises the next question: How find should be the grid? Those aren't problems which can not be solved. So, for example to attack the problem with the performance it is possible to transform the algorithm into the A*-Algorithm, which is actually just a modified maze router that prefers the shorter directions to the target. Also for the other problems there are solutions, which are mainly part of the more sophisticated routing algorithms.

\begin{figure}
	\centering
	\input{FIG/maze_router.svg}
	\caption{a wavefront explores the area till it reaches the target}
	\label{fig:maze_router}
\end{figure}

\subsubsection{Line Router}
The main difference from a line router to a maze router is the usage of lines as part of a route instead of points. This improves the memory usage and also usually avoids unnecessary bends, but at the same time this modification causes the loss of the guarantee to find the shortest path \cite[p. 695]{kaufmann:electronic_design_automation}. The other big difference lies in the search algorithm itself, as the line router performs a depth-first search instead of a breadth-first search like the maze router. The basic idea behind this type of router is to try to reach the target, or at least one of its coordinates in the first step, through an as long as possible line. This line may hit an obstacle, which means that the direction must be changed. And in this way the router always goes as far as possible into a direction and changes the direction till he reaches the target.

\subsection{Steiner Routing}
The algorithms above only considered two-pin nets, but very often nets have more than two pins. For these cases a possible solution would be to consider always only two pins at a time and connect the others sequentally to the previous ones. This can result in a lot worse results than the optimum \cite[p. 701]{kaufmann:electronic_design_automation}. A better approach is to use a Steiner-tree \cite[page 153]{springer:eda_analog_routing}.

\subsection{Sophisticated Routing Algorithms}
As it is not the topic of this thesis to describe in detail every possible routing algorithm I just want to bring here up some possible approaches. They are build around several very nice ideas but had all one drawback, which made them not useful for the used hierarchical placer, or were a bit to complex to be easy to implement. As the target of this thesis is mainly to create feasible and useful, but not perfect, layouts, I haven't chosen one of these sophisticated algorithms.
\begin{itemize}
\item ROSA \cite[page 165]{springer:eda_analog_routing}
\item MIGHTY \cite[page 166]{springer:eda_analog_routing}
\item ILAC \cite[page 167]{springer:eda_analog_routing}
\item SALIM \cite[page 167]{springer:eda_analog_routing}
\item SLAM \cite[page 167]{springer:eda_analog_routing}
\item Hierarhical global router \cite[page 168]{springer:eda_analog_routing}
\item Plan-based layout algorithm \cite[page 168]{springer:eda_analog_routing}
\item ANAGRAM \cite[page 168]{springer:eda_analog_routing}
\item ANAGRAM II \cite[page 168]{springer:eda_analog_routing}
\item area router \cite[page 168]{springer:eda_analog_routing}
\item modified Lee's algorithm \cite[page 170]{springer:eda_analog_routing}
\item ROAD \cite[page 170]{springer:eda_analog_routing}
\item ANAGRAM III \cite[page 170]{springer:eda_analog_routing}
\item router with constraint generator \cite[page 172]{springer:eda_analog_routing}
\end{itemize}

\subsection{Routing algorithms integrated into the placer}
It could be a very good idea to try to integrate the routing into the placer. Possible approaches into this direction are KOAN \cite[page 178]{springer:eda_analog_routing}, RACHANA \cite[page 178]{springer:eda_analog_routing}, GELSA \cite[page 179]{springer:eda_analog_routing}, and several others. The major problem with these solutions is the big modification of the placer. Actually it is quite useless to try to integrate the routing algorithm this way afterwards into a placer, as the placer must be created for this case with the routing in mind from the beginning. As the placer in Plantage wasn't supposed to include also the routing algorithm I had to use a different approach.

\subsection{Template Based Algorithms}
Template based algorithms start not from scratch, they already have a possible layout for a slightly different circuit or technology. Such a solution can be used in several cases and gives the layout designer nearly the full control over the process. But in my case I have to assume that there is no such template available and the intention of the whole set of tools would be, that the user has to provide as less information as possible. This would really mean \textit{electronic design \textbf{automation}} and should be the real target.

\section{Implemented Routing Algorithms}
The first decision to make was which algorithms should I implement. The more sophisticated solutions, or all global and detailed approaches seemed a bit to complex to implement them clean in only a few weeks. So the real choice was to implement something based on a maze or a line router. As the line routers seemed to be a good trade-off between complexity and performance I implemented something based on them. In the end I've implemented three different routing algorithms: First of all a typical line expansion router. This solutions doesn't consider all constraints, but it is able to create at least reasonable results. Afterwards this algorithm was extended to consider additional constraints. To improve the performance I also implemented a very special version of the line expansion router which really only creates feasible, but not very useful routings. This router can be used for the pre-routing, where the results are not stored anyway.

\subsection{Line Expansion Router}

\subsubsection{Select a Target}
The first thing which the algorithm has to do, before it can calculate a route, is to selected the start and target contact area. There can be several possibilities, as every pin can have several contact areas. Later on we will even see that already created routes can be candidates to start or end with a route. Basically this task can be seen as the selection of the closest rectangles of two lists of possibilities. For this I first want to talk a little bit about how the closest distance between two rectangles can be calculated.

For two rectangles there are several possible constellations. The first one I check is, if they overlap. If this is the case I can calculate easily the rectangle which is covered by both \nref{fig:rectangles_overlapping}. The distance is 0 in this case, and as start points for both rectangles I can select the center of gravity of the overlapping area.

\begin{figure}
	\centering
	\input{FIG/rectangles_overlapping.svg}
  	\caption{overlapping area of two rectangles is again a rectangle}
	\label{fig:rectangles_overlapping}
\end{figure}

If the two rectangles do not overlap it becomes a little bit more difficult. In this case I can at least say, that one of the rectangle has its closest point at one of the. Actually there can be even an endless count of solutions for this problem, but I'm only interested in one of them. Because of this I select the easiest to calculate solution, which means the selection of a corner for one rectangle. The closest corner from the first rectangle to the second one is that one, which has the closest euclidean distance to the center of gravity of the second one \nref{fig:rectangles_closest_corner}. As I now know for one rectangle the closest point I can start to select the closest point on the second one. This point must be obviously on one of the edges. Every edge is basically a line segment, where the closest point can be calculated easily. For this task I first need the expansion of the line segment into a whole line. I then can turn this line 90 degrees (it doesn't matter in which direction as it is a line) and move this new line, so that it crosses the point, from which I want to know the closest point on the line segment. The crossing point of these two lines, if it is also inside the line segment, is the closest point. If this crossing point is outside the line segment the closest point must be the start or end point of the line segment, which are actually the rectangle's corners.

\begin{figure}
	\centering
	\input{FIG/rectangles_closest_corner.svg}
  	\caption{the closest corner is that one, which has the smallest distance to the center of gravity of the other one}
	\label{fig:rectangles_closest_corner}
\end{figure}

\subsubsection{Consider Obstacles}
After the algorithm has selected start and target contact areas the next step is to avoid routes across modules. For this purpose during all the following steps the modules are considered as obstacles. But during the first step usually the route has first to get out of the module. To avoid additional, accidentally added, gates the algorithm has to choose the shortest way to get out of the module. To avoid problems with the design rules it is not possible to start right at the contact area to the next layer and use for example metal to get out of the module as fast as possible.

As the algorithm now has all the necessary information the actual line expansion routing can start. The main idea behind a line expansion router is that the routes are created sequentially. Every single step is based on a map of obstacles, which the route mustn't cross. From the starting point beginning I always calculate the next possible point of a route and apply the same algorithm afterwards again to this partial problem. At the beginning of this recursive algorithm, as usual, I check the terminating condition: If I have reached the target point.

In every single step I have to make several decisions: First I group the possible directions in good and bad directions \nref{fig:router_good_bad_direction}. Good directions are those, which reduce the distance to the target, and bad ones are all the others.

\begin{figure}
	\centering
	\input{FIG/router_good_bad_direction.svg}
  	\caption{good and bad directions}
	\label{fig:router_good_bad_direction}
\end{figure}

Additionally it makes no sense to go back the same direction where the last step came from. Also the same direction like the last step is not senseful. Because if this would be a good decision, the last step could have gone further. So I remove these two directions from the good directions. After this selection I can make one step further in every good directon, as far as possible. This means, that the next step can go as far, as no obstacle is on the way or the target (in this coordinate) is reached \nref{fig:router_go_as_far_as_possible}.

\begin{figure}
	\centering
	\subfloat[no obstacle]{\includegraphics[scale=0.8]{FIG/router_as_far_as_possible.png}}
	\subfloat[with obstacle]{\includegraphics[scale=0.8]{FIG/router_as_far_as_possible_obstacle.png}}
	\caption{in a good direction the route can go as far as possible}
	\label{fig:router_go_as_far_as_possible}
\end{figure}


During the calculation of the steps towards the target I count those, which are feasible. If none of them is feasible I will have to select one of the bad directions for the next step. A major premission for this is also, that our last step ended at an obstacle. The router now can go as far as necessary into this bad direction \nref{fig:router_as_far_as_necessary}.

\begin{figure}
	\centering
	\input{FIG/router_as_far_as_necessary.svg}
 	\caption{a step into a bad direction should go only as far as necessary}
	\label{fig:router_as_far_as_necessary}
\end{figure}

Last but no least it is also possible to switch to the neighboured layers. For modules the obstacle can not be crossed with this way, as they are obstacles at every layer. But if for example the obstacle is just another route a layer switch may solve the problem.

\subsubsection{Avoid Collisions}
To avoid collisions I take into account the preferred directions for every layer. This information is again stored in the technology file and describes, if a layer should be used for horziontal or vertical routes. This reduces the possibility of collisions very efficiently and results in less complex layouts.

\subsubsection{Symmetric Routes}
In manually created layouts an usual way to route symmetric elements is to create them optical symmetric. This optical symmetry gives the designer an easy way to create symmetry. But the really important part about routing symmetries is to match the parasitics. The resistance of the route is for sure matched for the symmetric routes through an optical symmetry, but the capacitive couplings are obeyed in most cases. Therefore I concentrated on the resistance. To also consider the capacities it would have been necessary to create all routes at the same time, because only with such an approach I can evaluate the capacitive parasitics, otherwise I never know what influence routes will have that will be created afterwards. As I have chosen to create the routes one by one I can't consider the capacities for the symmetries.

But before I go more into detail of the routing I want to explain the situation a bit more. Symmetries are caused by symmetry constraints, which can have, as already described earlier, single and pair modules. Single modules are quite useless for a symmetric routing. The only modules of interest are pair modules, no matter if they must be connected only together or also to another module.

In the routing I first extract all modules, which are symmetric and where both parts of the symmetry pair must be connected to the same net. Afterwards I connect these pairs together and the only possible start or end point for other routes is then the middle of the route between the pair. In this case middle doesn't have to mean the same distance to both sides, but the same resistance to both modules. Therefore, if for example the route uses different layers from the modules to the middle, it is possible that the middle in terms of resistance doesn't have to be the same like the middle in terms of distance.

\subsubsection{Guard Rings}
With guards a designer can protect for example a certain signal from another very noisy one or protect whole module groups. The latter one is for example often used for current mirrors, as they are very sensitive against noise. In physical representation a guard or guard ring is only a layer, for example MET1, contacted to the substrate and connected to a certain Voltage level (often ground). For routing this results only in an additional obstacle on this layer.

PICTURE MISSING OF GUARD RING MET1

The major difference of guard rings to usual obstacles is, that they are obstacles only for certain nets. Or, if you look at it the other way round, a guard ring isn't an obstacle for the nets inside. This is necessary, so that other routes do not use the space inside a guard ring, but the pins inside can still be connected. For example a MET1-guard will result in a normal obstacle, for all nets, on MET1. On all other routing layers there will be also obstacles, but only for nets which don't have pins inside the guard ring.

\subsubsection{Multi-Pin Nets}
To solve the problem of multi-pin nets it would be possible to use a Steiner-tree, as already described previously. But this approach wouldn't really be the easiest one to implement, so I've chosen a different solution. Basically I connect first the first two pins, and the order of the pins is random (actually they are sorted by there name alphabetically, but this was no intention and doesn't really matter). Afterwards I transform the whole new connection into additional possible targets and connect the next pin to this now bigger list of possible targets and select the closest one. The result from this step is again transformed into additional targets for the next pin, and so on.

\subsubsection{Select a Route}
Finally, if the start point is the same as the end point I have to calculate a feasible and complete route. I add This result to all the possible routes for this necessary connection. From these possible routes the first, quite simple, algorithm chooses only the best one. As this algorithm calculates the routes sequentially it has no information about for example capacitive couplings, therefore the \textit{best} possibility is chosen on the lowest resistance.

For this first algorithm a lot of different possibilities for every necessary connection is quite a lot of information, as it chooses only the shortest one in terms of resistance. But the results, which we generate here, can be reused for the extended version of the line expansion algorithm.

PICTURE MISSING OF ROUTED MILLER AMPLIFIER (LAYOUT)

\subsection{Line Expansion Feasibility Router}
In this special case I had to implement the routing into the hierarchical placing algorithm. This creates some additional requirements for the routing algorithms. The most important difference to an usual placer is that the actual positions of a module can change. Because of this the positions are even not stored, only the selected variants and the enumeration sequence is used to specify a certain placement. As the positions of the routes would be relative to the module positions it is not really useful to store the routing results for the next higher hierarchy level. Another reason for this is the possibility of other modules, which could overlap with routes after the calculation of the placement on the next higher level. But it is still important to try to route the placement, as a placement may cause very long or even infeasible routes. Because of these special requirements it is possible to select a different router for the pre routing step than for the final routing. Actually it would be possible to select here every router, but it is only reasonable to select one which requires less computing time.

And this is the point where the line expansion feasibility router comes into play. This algorithm is a modified version of the basic line expansion algorithm. The only difference  is the amount of possible routes which are created for every necessary connection. The basic version creates as much as possible and the modified version only one route. This will result in usually quite bad layouts, and because of this the router shouldn't be used for the final step. But as pre router the algorithm is quite useful, as it is very fast and can select very efficient, if a placement is at least feasible to route for a line expansion router.

\subsection{Extended Line Expansion Router}
This extended version of the line expansion router is based on the simple version. So it is again a sequential approach, with the same drawbacks and advantages as the previous versions. The main difference to it is how the different routes are combined to a complete net and how the possibilities are selected afterwards. But before I discuss the selection I want to describe how the possibilities are generated.

\subsubsection{Create Routes}
The routing is again seperated into the routing of the nets. For every possibility of the first net I create again the same amount of possibilities for every other net, and vice versa. One single net is created in the same manner, but in this case it is created by several routes. The first route connects the first two modules, the second route connects the third module to the already existing net, the third route connects the fourth module to the already existing net, and so on. As the line expansion algorithm creates a bunch of possibilities for every route I receive a whole set of possibilities for every net. The maximum number of this possibilities is limited by an algorithm parameter, which creates an implicit limitiation of the maximum possibilities of every route of a net.

This additional parameter is a quite important one for this version of the router as the computation time increases exponential with this number it is a good starting point if you want to reduce the time spent on routing. As one net can connect more than two modules this count must be distributed to the routes, which constitute the net. In the case of only two modules to connect it is quite easy, the router than selects the as much possibilities for this route as he can spent on the whole net. If there are more modules it becomes a bit more complicated, as for every selection of the first route there are again as much possibilities for the second one, and so on, if I distribute the possibilities equally to all parts of the net. If I continue this thought I get a maximum count of possibilities for each route ($x_{route}$) of a net with a total maximum count of possibilities ($x_{net}$) and $n$ modules:
\[x_{route} = \sqrt[n - 1]{x_{net}}\]

This formula can also be used for the case of only one module. As I want to exploit the total maximum count of possibilities the last route of a net can just create as much variants till the total maximum is reached.

\subsubsection{Select Routes}
The selection of the routes after the creations makes use of the parasitics. They should be minimized in all cases, the resistance and the capacities. For a minimum resistance only the length and the selection of layers is a matter from interest, but for the capacities the whole geometry must be taken into account. Also, as there are two different values to minimize, the user has to define how important which type of parasitic is to him. There can't be a general definition like \emph{resistance is twice imporant than capacity}. This depends on the whole circuit and the constraints which the designer wants to meet.

The actual selection of the route is quite easy: After the creation step I have a whole bunch of possible routings, where I calculate the parasitic sum
\[p = w_R \cdot R + w_C \cdot C\]
(where $w_R$ is the weight for the resistance, $w_C$ the weight for the capacity, $R$ the total resistance and $C$ the total capacity) for every routing. The best one in this term is then the one with the smallest parasitic sum.

PICTURE MISSING OF ROUTED MILLER AMPLIFIER (LAYOUT)